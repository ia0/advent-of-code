use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::{BufRead, BufReader};

const ADJACENT: &[[i64; 4]; 80] = &[
    [-1, -1, -1, -1],
    [-1, -1, -1, 0],
    [-1, -1, -1, 1],
    [-1, -1, 0, -1],
    [-1, -1, 0, 0],
    [-1, -1, 0, 1],
    [-1, -1, 1, -1],
    [-1, -1, 1, 0],
    [-1, -1, 1, 1],
    [-1, 0, -1, -1],
    [-1, 0, -1, 0],
    [-1, 0, -1, 1],
    [-1, 0, 0, -1],
    [-1, 0, 0, 0],
    [-1, 0, 0, 1],
    [-1, 0, 1, -1],
    [-1, 0, 1, 0],
    [-1, 0, 1, 1],
    [-1, 1, -1, -1],
    [-1, 1, -1, 0],
    [-1, 1, -1, 1],
    [-1, 1, 0, -1],
    [-1, 1, 0, 0],
    [-1, 1, 0, 1],
    [-1, 1, 1, -1],
    [-1, 1, 1, 0],
    [-1, 1, 1, 1],
    [0, -1, -1, -1],
    [0, -1, -1, 0],
    [0, -1, -1, 1],
    [0, -1, 0, -1],
    [0, -1, 0, 0],
    [0, -1, 0, 1],
    [0, -1, 1, -1],
    [0, -1, 1, 0],
    [0, -1, 1, 1],
    [0, 0, -1, -1],
    [0, 0, -1, 0],
    [0, 0, -1, 1],
    [0, 0, 0, -1],
    [0, 0, 0, 1],
    [0, 0, 1, -1],
    [0, 0, 1, 0],
    [0, 0, 1, 1],
    [0, 1, -1, -1],
    [0, 1, -1, 0],
    [0, 1, -1, 1],
    [0, 1, 0, -1],
    [0, 1, 0, 0],
    [0, 1, 0, 1],
    [0, 1, 1, -1],
    [0, 1, 1, 0],
    [0, 1, 1, 1],
    [1, -1, -1, -1],
    [1, -1, -1, 0],
    [1, -1, -1, 1],
    [1, -1, 0, -1],
    [1, -1, 0, 0],
    [1, -1, 0, 1],
    [1, -1, 1, -1],
    [1, -1, 1, 0],
    [1, -1, 1, 1],
    [1, 0, -1, -1],
    [1, 0, -1, 0],
    [1, 0, -1, 1],
    [1, 0, 0, -1],
    [1, 0, 0, 0],
    [1, 0, 0, 1],
    [1, 0, 1, -1],
    [1, 0, 1, 0],
    [1, 0, 1, 1],
    [1, 1, -1, -1],
    [1, 1, -1, 0],
    [1, 1, -1, 1],
    [1, 1, 0, -1],
    [1, 1, 0, 0],
    [1, 1, 0, 1],
    [1, 1, 1, -1],
    [1, 1, 1, 0],
    [1, 1, 1, 1],
];

fn step(old: &HashSet<[i64; 4]>) -> HashSet<[i64; 4]> {
    let mut count = HashMap::new();
    for &p in old {
        for mut c in ADJACENT.iter().cloned() {
            for i in 0 .. 4 {
                c[i] += p[i];
            }
            *count.entry(c).or_default() += 1;
        }
    }
    let mut new = HashSet::new();
    for (&p, &c) in count.iter() {
        if (old.contains(&p) && 2 <= c && c <= 3) || (!old.contains(&p) && c == 3) {
            new.insert(p);
        }
    }
    new
}

fn main() {
    let input = File::open("examples/17.txt").unwrap();
    let mut state = HashSet::new();
    for (y, line) in BufReader::new(input).lines().enumerate() {
        let line = line.unwrap();
        for (x, c) in line.bytes().enumerate() {
            match c {
                b'.' => (),
                b'#' => assert!(state.insert([x as i64, y as i64, 0, 0])),
                _ => unreachable!(),
            }
        }
    }
    for _ in 0 .. 6 {
        state = step(&state);
    }
    println!("{}", state.len());
}
